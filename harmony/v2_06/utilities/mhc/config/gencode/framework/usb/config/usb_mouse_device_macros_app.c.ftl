<#-- usb_mouse_device_macros_app.c.ftl -->

<#--
// *****************************************************************************
// Section: Included Files 
// *****************************************************************************

#include "${APP_NAME?lower_case}.h"
-->
<#macro macro_lib_usb_app_c_includes>
</#macro>

<#--
// *****************************************************************************
// *****************************************************************************
// Section: Global Data Definitions
// *****************************************************************************
// *****************************************************************************

// *****************************************************************************
/* Application Data
*/
-->
<#macro macro_lib_usb_app_c_global_data>

/* Static buffers, suitable for DMA transfer, to send mouse reports */
static MOUSE_REPORT mouseReport         APP_MAKE_BUFFER_DMA_READY;
static MOUSE_REPORT mouseReportPrevious APP_MAKE_BUFFER_DMA_READY;
</#macro>

<#--
// *****************************************************************************
// Section: Application Callback Functions
// *****************************************************************************
-->
<#macro macro_lib_usb_app_c_callback_functions>

/*******************************************************************************
  Function:
    void APP_USBDeviceHIDEventHandler (USB_DEVICE_HID_INDEX hidInstance,
                                       USB_DEVICE_HID_EVENT event, 
                                       void *               eventData, 
                                       uintptr_t            userData)

  Summary:
    Event callback generated by USB device layer.

  Description:
    This event handler will handle all device layer events.

  Parameters:
    None.

  Returns:
    None.
*/
static void APP_USBDeviceHIDEventHandler(USB_DEVICE_HID_INDEX hidInstance,
                                         USB_DEVICE_HID_EVENT event, 
                                         void *               eventData, 
                                         uintptr_t            userData)
{
    ${APP_NAME?upper_case}_DATA * ${APP_NAME?lower_case}Data = (${APP_NAME?upper_case}_DATA *)userData;

    switch(event)
    {
        case USB_DEVICE_HID_EVENT_REPORT_SENT:

            /* This means the mouse report was sent.
             We are free to send another report */

            ${APP_NAME?lower_case}Data->isMouseReportSendBusy = false;
            break;

        case USB_DEVICE_HID_EVENT_REPORT_RECEIVED:

            /* Dont care for other event in this demo */
            break;

        case USB_DEVICE_HID_EVENT_SET_IDLE:

             /* Acknowledge the Control Write Transfer */
           USB_DEVICE_ControlStatus(${APP_NAME?lower_case}Data->handleUsbDevice, USB_DEVICE_CONTROL_STATUS_OK);

            /* save Idle rate received from Host */
            ${APP_NAME?lower_case}Data->idleRate = ((USB_DEVICE_HID_EVENT_DATA_SET_IDLE*)eventData)->duration;
            break;

        case USB_DEVICE_HID_EVENT_GET_IDLE:

            /* Host is requesting for Idle rate. Now send the Idle rate */
            USB_DEVICE_ControlSend(${APP_NAME?lower_case}Data->handleUsbDevice, &(${APP_NAME?lower_case}Data->idleRate),1);

            /* On successfully receiving Idle rate, the Host would acknowledge back with a
               Zero Length packet. The HID function driver returns an event
               USB_DEVICE_HID_EVENT_CONTROL_TRANSFER_DATA_SENT to the application upon
               receiving this Zero Length packet from Host.
               USB_DEVICE_HID_EVENT_CONTROL_TRANSFER_DATA_SENT event indicates this control transfer
               event is complete */ 

            break;

        case USB_DEVICE_HID_EVENT_SET_PROTOCOL:
            /* Host is trying set protocol. Now receive the protocol and save */
            ${APP_NAME?lower_case}Data->activeProtocol = *(USB_HID_PROTOCOL_CODE *)eventData;

              /* Acknowledge the Control Write Transfer */
            USB_DEVICE_ControlStatus(${APP_NAME?lower_case}Data->handleUsbDevice, USB_DEVICE_CONTROL_STATUS_OK);
            break;

        case  USB_DEVICE_HID_EVENT_GET_PROTOCOL:

            /* Host is requesting for Current Protocol. Now send the Idle rate */
             USB_DEVICE_ControlSend(${APP_NAME?lower_case}Data->handleUsbDevice, &(${APP_NAME?lower_case}Data->activeProtocol), 1);

             /* On successfully receiving Idle rate, the Host would acknowledge
               back with a Zero Length packet. The HID function driver returns
               an event USB_DEVICE_HID_EVENT_CONTROL_TRANSFER_DATA_SENT to the
               application upon receiving this Zero Length packet from Host.
               USB_DEVICE_HID_EVENT_CONTROL_TRANSFER_DATA_SENT event indicates
               this control transfer event is complete */
             break;

        case USB_DEVICE_HID_EVENT_CONTROL_TRANSFER_DATA_SENT:
            break;

        default:
            break;
    }
}

/*******************************************************************************
  Function:
    void APP_USBDeviceEventHandler (USB_DEVICE_EVENT event,
        USB_DEVICE_EVENT_DATA * eventData)

  Summary:
    Event callback generated by USB device layer.

  Description:
    This event handler will handle all device layer events.

  Parameters:
    None.

  Returns:
    None.
*/

static void APP_USBDeviceEventHandler(USB_DEVICE_EVENT event, void * eventData, uintptr_t context)
{
    USB_DEVICE_EVENT_DATA_CONFIGURED * configurationValue;
    
    switch(event)
    {
        case USB_DEVICE_EVENT_SOF:
            
            /* Increment idle time at start of frame */
            ${APP_NAME?lower_case}Data.setIdleTimer++;
            
            break;
            
        case USB_DEVICE_EVENT_RESET:
        case USB_DEVICE_EVENT_DECONFIGURED:
        
            /* Device got deconfigured */
            ${APP_NAME?lower_case}Data.usbDeviceIsConfigured = false;

            break;

        case USB_DEVICE_EVENT_CONFIGURED:

            /* Device is configured */
            configurationValue = (USB_DEVICE_EVENT_DATA_CONFIGURED *)eventData;
            if(configurationValue->configurationValue == 1)
            {
                /* Register the Application HID Event Handler. */
                USB_DEVICE_HID_EventHandlerSet(USB_DEVICE_HID_INDEX_0,
                        APP_USBDeviceHIDEventHandler, (uintptr_t)&${APP_NAME?lower_case}Data);
                
                ${APP_NAME?lower_case}Data.usbDeviceIsConfigured = true;
                
                ${APP_NAME?lower_case}Data.isMouseReportSendBusy = false;
                ${APP_NAME?lower_case}Data.emulateMouse          = true;
            }
            break;

        case USB_DEVICE_EVENT_POWER_DETECTED:

            /* VBUS was detected. We can attach the device */
            USB_DEVICE_Attach(${APP_NAME?lower_case}Data.handleUsbDevice);
            
            break;

        case USB_DEVICE_EVENT_POWER_REMOVED:

            /* VBUS is not available any more. Detach the device. */
            USB_DEVICE_Detach(${APP_NAME?lower_case}Data.handleUsbDevice);
            
            break;

        case USB_DEVICE_EVENT_SUSPENDED:
            break;

        case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_RECEIVED:
        case USB_DEVICE_EVENT_CONTROL_TRANSFER_ABORTED:
        case USB_DEVICE_EVENT_CONTROL_TRANSFER_SETUP_REQUEST:
        case USB_DEVICE_EVENT_CONTROL_TRANSFER_DATA_SENT:
        case USB_DEVICE_EVENT_ENDPOINT_READ_COMPLETE:
        case USB_DEVICE_EVENT_ENDPOINT_WRITE_COMPLETE:
        case USB_DEVICE_EVENT_SET_DESCRIPTOR:
        case USB_DEVICE_EVENT_SYNCH_FRAME:
        case USB_DEVICE_EVENT_RESUMED:
        case USB_DEVICE_EVENT_ERROR:
        default:
            break;

    } 
}
</#macro>

<#--
// *****************************************************************************
// Section: Application Local Functions
// *****************************************************************************
-->
<#macro macro_lib_usb_app_c_local_functions>

// *****************************************************************************
/* Function:
    void MOUSE_ReportCreate
    (
        MOUSE_COORDINATE x, 
        MOUSE_COORDINATE y,
        MOUSE_BUTTON_STATE * buttonArray,
        MOUSE_REPORT * mouseReport
    )

  Summary:
    This function creates a mouse report.

  Description:
    This function creates a mouse report. The application can use this function 
    to create the mouse report. The report can then be sent to the host by using
    the USB_DEVICE_HID_ReportSend() function.

  Precondition:
    None.

  Parameters:
    x - Mouse X Coordinate

    y - Mouse Y Coordinate

    buttonArray - Pointer to an array of button states. Size of the array is
    defined by USB_HID_MOUSE_BUTTON_NUBMERS.
    
    mouseReport - Output only variable that will contain the mouse report.

  Returns:
    None.

  Example:
    <code>
    // This example shows how to create and send the mouse report. Assume
    // that device is configured. Number of mouse buttons is 3. Assume that
    // this mouse is associated with HID Device Instance 0.

	MOUSE_REPORT mouseReport;
    MOUSE_BUTTON_STATE mouseButtons[USB_HID_MOUSE_BUTTON_NUMBERS];
    MOUSE_COORDINATE xCoordinate;
    MOUSE_COORDINATE yCoordinate;
    USB_DEVICE_HID_TRANSFER_HANDLE transferHandle;
    USB_DEVICE_HID_RESULT result;

    // Update the mouse state

    xCoordinate = someXCoordinate;
    yCoordinate = someYCoordinate;
    mouseButtons[0] = USB_HID_MOUSE_BUTTON_STATE_PRESSED;
    mouseButtons[1] = USB_HID_MOUSE_BUTTON_STATE_RELEASED;
    mouseButtons[2] = USB_HID_MOUSE_BUTTON_STATE_RELEASED;

    // Create the report.

    MOUSE_ReportCreate( xCoordinate, yCoordinate, 
        mouseButtons, &mouseReport);

    // Now send the report
  
    result = USB_DEVICE_HID_ReportSend( 0, &transferHandle,  
               (uint8_t *)mouseReport, sizeof(USB_HID_MOUSE_REPORT));

    if(USB_DEVICE_HID_RESULT_OK != result)
    {
        // Do error handling here.
    } 

    // The completion of the report send is indicated by the 
    // USB_DEVICE_HID_EVENT_REPORT_SEND_COMPLETE event.

    </code>

  Remarks:
    None.
*/

static void MOUSE_ReportCreate
(
    MOUSE_COORDINATE x,
    MOUSE_COORDINATE y,
    MOUSE_BUTTON_STATE * buttonArray,
    MOUSE_REPORT * mouseReport
)
{
    int index;

    /* Initialize the mouse buttons byte */
    mouseReport->data[0] = 0;

    for (index = 0; index < MOUSE_BUTTON_NUMBERS; index ++)
    {
        /* Create the mouse button bit map */
        mouseReport->data[0] |= buttonArray[index];
    }

    /* Update the x and y co-ordinate */
	mouseReport->data[1] = x;
	mouseReport->data[2] = y;

	return;	
}

/******************************************************************************
  Function:
    static void USB_Task (void)
    
   Remarks:
    Services the USB task. 
*/
static void USB_Task (void)
{
    static int8_t   vector          = 0;
    static uint8_t  movement_length = 0;
    static bool     sent_dont_move  = false;
    
    static const int8_t dir_table[] = {-4,-4,-4, 0, 4, 4, 4, 0};
    
<#if ("CONFIG_APP_Mouse_UPON_EVENT" + "${HCONFIG_APP_INSTANCE}")?eval>
<#if ("CONFIG_APP_Mouse_UPON_EVENT_COUNT" + "${HCONFIG_APP_INSTANCE}")?eval?number != 1>
    static uint32_t usbEventCount   = 0;
</#if>
</#if>

<#if ("CONFIG_APP_Mouse_UPON_EVENT" + "${HCONFIG_APP_INSTANCE}")?eval>
    if (<@global_event_triggered eventName=("CONFIG_APP_Mouse_UPON_EVENT_NAME" + "${HCONFIG_APP_INSTANCE}")?eval/>)
    {
<#if ("CONFIG_APP_Mouse_UPON_EVENT_COUNT" + "${HCONFIG_APP_INSTANCE}")?eval?number != 1>
        usbEventCount++;

        if (usbEventCount >= ${APP_NAME?upper_case}_USB_EVENT_COUNT)
        {
            usbEventCount = 0;
            
            // Toggle emulating mouse
            ${APP_NAME?lower_case}Data.emulateMouse = !${APP_NAME?lower_case}Data.emulateMouse;
        }
<#else>
        // Toggle emulating mouse
        ${APP_NAME?lower_case}Data.emulateMouse = !${APP_NAME?lower_case}Data.emulateMouse;
</#if>
    }
</#if>
    
    if(${APP_NAME?lower_case}Data.usbDeviceIsConfigured)
    {
        if(${APP_NAME?lower_case}Data.emulateMouse)
        {
            sent_dont_move = false;

            if(movement_length > 50)
            {
                ${APP_NAME?lower_case}Data.mouseButton[0] = MOUSE_BUTTON_STATE_RELEASED;
                ${APP_NAME?lower_case}Data.mouseButton[1] = MOUSE_BUTTON_STATE_RELEASED;
                ${APP_NAME?lower_case}Data.xCoordinate =(int8_t)dir_table[vector & 0x07] ;
                ${APP_NAME?lower_case}Data.yCoordinate =(int8_t)dir_table[(vector+2) & 0x07];
                vector ++;
                movement_length = 0;
            }
        }
        else
        { 
            ${APP_NAME?lower_case}Data.mouseButton[0] = MOUSE_BUTTON_STATE_RELEASED;
            ${APP_NAME?lower_case}Data.mouseButton[1] = MOUSE_BUTTON_STATE_RELEASED;
            ${APP_NAME?lower_case}Data.xCoordinate = 0;
            ${APP_NAME?lower_case}Data.yCoordinate = 0;
        }

        if(!${APP_NAME?lower_case}Data.isMouseReportSendBusy)
        {
            if( ((sent_dont_move == false) && (!${APP_NAME?lower_case}Data.emulateMouse)) 
                || (${APP_NAME?lower_case}Data.emulateMouse))
            {

                /* This means we can send the mouse report. The
                   isMouseReportBusy flag is updated in the HID Event Handler. */
                ${APP_NAME?lower_case}Data.isMouseReportSendBusy = true;

                /* Create the mouse report */
                MOUSE_ReportCreate(${APP_NAME?lower_case}Data.xCoordinate, 
                                   ${APP_NAME?lower_case}Data.yCoordinate,
                                   ${APP_NAME?lower_case}Data.mouseButton, 
                                   &mouseReport);

                if(memcmp((const void *)&mouseReportPrevious, 
                          (const void *)&mouseReport,
                          (size_t)sizeof(mouseReport)) == 0)
                {
                    /* Reports are same as previous report. However mouse reports
                     * can be same as previous report as the co-ordinate positions are relative.
                     * In that case it needs to be send */
                    if((${APP_NAME?lower_case}Data.xCoordinate == 0) && (${APP_NAME?lower_case}Data.yCoordinate == 0))
                    {
                        /* If the coordinate positions are 0, that means there
                         * is no relative change */
                        if(${APP_NAME?lower_case}Data.idleRate == 0)
                        {
                            ${APP_NAME?lower_case}Data.isMouseReportSendBusy = false;
                        }
                        else
                        {
                            /* Check the idle rate here. If idle rate time elapsed
                             * then the data will be sent. Idle rate resolution is
                             * 4 msec as per HID specification; possible range is
                             * between 4msec >= idlerate <= 1020 msec.
                             */
                            if(${APP_NAME?lower_case}Data.setIdleTimer * APP_USB_CONVERT_TO_MILLISECOND
                                    >= ${APP_NAME?lower_case}Data.idleRate * 4)
                            {
                                /* Send REPORT as idle time has elapsed */
                                ${APP_NAME?lower_case}Data.isMouseReportSendBusy = true;
                            }
                            else
                            {
                                /* Do not send REPORT as idle time has not elapsed */
                                ${APP_NAME?lower_case}Data.isMouseReportSendBusy = false;
                            }
                        }
                    }

                }
                if(${APP_NAME?lower_case}Data.isMouseReportSendBusy == true)
                {
                    /* Copy the report sent to previous */
                    memcpy((void *)&mouseReportPrevious, (const void *)&mouseReport,
                            (size_t)sizeof(mouseReport));

                    /* Send the mouse report. */
                    USB_DEVICE_HID_ReportSend(USB_DEVICE_INDEX_0,
                        &${APP_NAME?lower_case}Data.reportTransferHandle, (uint8_t*)&mouseReport,
                        sizeof(MOUSE_REPORT));
                    ${APP_NAME?lower_case}Data.setIdleTimer = 0;
                }
                movement_length ++;
                sent_dont_move = true;
            }
        }
    }
}
</#macro>

<#--
// *****************************************************************************
// Section: Application Initialization and State Machine Functions
// *****************************************************************************
// *****************************************************************************

/*******************************************************************************
  Function:
    void ${APP_NAME?upper_case}_Initialize ( void )

  Remarks:
    See prototype in ${APP_NAME?lower_case}.h.
 */

void ${APP_NAME?upper_case}_Initialize ( void )
{
    /* Place the App state machine in its initial state. */
    ${APP_NAME?lower_case}Data.state = ${APP_NAME?upper_case}_STATE_INIT;
-->
<#macro macro_lib_usb_app_c_initialize>

    { 
        int i;
        
        /* Iniitalize USB Mouse Device application data */
        ${APP_NAME?lower_case}Data.handleUsbDevice       = USB_DEVICE_HANDLE_INVALID;
        ${APP_NAME?lower_case}Data.usbDeviceIsConfigured = false;
        ${APP_NAME?lower_case}Data.emulateMouse          = true;
        ${APP_NAME?lower_case}Data.isMouseReportSendBusy = false;
        ${APP_NAME?lower_case}Data.xCoordinate           = 0;
        ${APP_NAME?lower_case}Data.yCoordinate           = 0;
        ${APP_NAME?lower_case}Data.idleRate              = 0;
        ${APP_NAME?lower_case}Data.setIdleTimer          = 0;
        
        for (i=0; i<MOUSE_BUTTON_NUMBERS; i++)
        {
            ${APP_NAME?lower_case}Data.mouseButton[i] = MOUSE_BUTTON_NUMBERS;
        }
     }
</#macro>

<#--
}


/******************************************************************************
  Function:
    void ${APP_NAME?upper_case}_Tasks ( void )

  Remarks:
    See prototype in ${APP_NAME?lower_case}.h.
 */

void ${APP_NAME?upper_case}_Tasks ( void )
{
-->
<#macro macro_lib_usb_app_c_tasks_data>
</#macro>

<#--
    /* Check the application's current state. */
    switch ( ${APP_NAME?lower_case}Data.state )
    {
        /* Application's initial state. */
        case ${APP_NAME?upper_case}_STATE_INIT:
        {
            bool appInitialized = true;
-->   
<#macro macro_lib_usb_app_c_tasks_state_init>

            /* Open the device layer */
            if (${APP_NAME?lower_case}Data.handleUsbDevice == USB_DEVICE_HANDLE_INVALID)
            {
                ${APP_NAME?lower_case}Data.handleUsbDevice = USB_DEVICE_Open( USB_DEVICE_INDEX_0,
                                               DRV_IO_INTENT_READWRITE );
                appInitialized &= ( USB_DEVICE_HANDLE_INVALID != ${APP_NAME?lower_case}Data.handleUsbDevice );
            }
</#macro>    

<#--        
            if (appInitialized)
            {
-->
<#macro macro_lib_usb_app_c_tasks_calls_after_init>

                /* Register a callback with device layer to get event notification (for end point 0) */
                USB_DEVICE_EventHandlerSet(${APP_NAME?lower_case}Data.handleUsbDevice,
                                           APP_USBDeviceEventHandler, 0);
</#macro>

<#--            /* Advance to the next state */
                ${APP_NAME?lower_case}Data.state = ${APP_NAME?upper_case}_STATE_SERVICE_TASKS;
            }
            break;
        }

        case ${APP_NAME?upper_case}_STATE_SERVICE_TASKS:
        {
-->
<#macro macro_lib_usb_app_c_tasks_state_service_tasks>
            USB_Task();
</#macro>

<#--        
            break;
        }

        /* The default state should never be executed. */
        default:
        {
            /* TODO: Handle error in application's state machine. */
            break;
        }
    }
}
-->

<#macro macro_lib_usb_app_c_tasks_states>
</#macro>
